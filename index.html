<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exam Form</title>
    <link rel="icon" href=favicon.svg type="image/svg+xml">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-top: 20px;
        }
        h2 {
            margin-top: 5px;
        }

        form {
            margin-bottom: 20px;
            width: 45%;
        }

        .top-section {
            display: flex;
            justify-content: space-between;
            width: 80%;
            margin-top: 10px;
            gap: 5px;
        }

        .input-form {
            width: 45%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            background: #fff;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            height: auto;
        }

        .input-form .form-group {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .input-form label {
            flex: 1;
            margin-right: 10px;
        }

        .input-form input, .custom-select {
            flex: 1;
            width: 40%;
            /* height: auto; */
        }
        .custom-select {
            width: 100%;   /* Make the width consistent with the upper div */
            padding: 5px; /* Add some padding for a better look */
            font-size:15px; /* Adjust the font size */
            border-radius: 4px; /* Add rounded corners */
            border: 1px solid #ccc; /* Add a border */
            box-shadow: inset 0 1px 1px rgba(0,0,0,0.075); /* Add some inner shadow */
            -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,0.075); /* For Safari */
            background-color: #fff; /* Ensure background color is white */
            appearance: none; /* Remove default styling */
        }

        .custom-select:focus {
            border-color: #007bff; /* Change border color on focus */
            outline: none; /* Remove outline */
            box-shadow: 0 0 5px rgba(0,123,255,0.5); /* Add box shadow on focus */
        }

        #timeAnalysis {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 15px; /* Adjust the space between elements as needed */
            flex-wrap: wrap; /* Allow wrapping if the screen is too narrow */
        }

        .new-form-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-right: 10px; /* Add some space between groups */
        }

        .new-form-group label {
            margin-bottom: 5px;
        }

        .horizontal-buttons {
            display: flex;
            gap: 10px; /* Space between buttons */
        }



        .timer-container {
            text-align: center;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        #timer {
            font-size: 2em;
            margin: 20px 0;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
        }

        button:hover {
            background-color: #0056b3;
        }

        .form-container-wrapper {
            border: 1px solid black;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            background-color: #f9f9f9;
            display: none;
        }

        .form-container {
            display: flex;
        }

        .column {
            flex: 1;
            padding: 10px;
            border-right: 1px solid #000;
        }

        .column:last-child {
            border-right: none;
        }

        .question {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .question-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .radio-group {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        .radio-label {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }

        .result-container {
            display: none;
            flex-direction: row;
            align-items: flex-start;
            margin: 20px;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 10px;
            background-color: #f9f9f9;
        }

        .your-response-container {
            flex: 2; /* Increase the flex value to give more space */
            margin-right: 20px;
        }

        .assessment-container {
            flex: 1; /* Adjust the flex value to balance the layout */
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        .your-response-container th, .your-response-container td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .your-response-container th {
            background-color: #f2f2f2;
        }
        .result-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .result-item label {
            margin-right: 10px;
        }

        .correct {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid green;
            border-radius: 3px;
            position: relative;
        }

        .correct:checked::before {
            content: '✔';
            color: green;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 18px;
        }

        .incorrect {
            appearance: none;
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid red;
            border-radius: 3px;
            position: relative;
        }

        .incorrect:checked::before {
            content: '✘';
            color: red;
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 18px;
        } 
        .summary-button-container {
            /* margin-top: 5px; */
            text-align: center;
        }

        #summaryButton {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #summaryButton:hover {
            background-color: #0056b3;
        }

        .summary-container {
            /* margin-top: 5px; */
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .summary-table th, .summary-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .summary-table th {
            background-color: #f2f2f2;
        }

        .time-summary-container {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .time-summary-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .time-summary-table th, .time-summary-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        .time-summary-table th {
            background-color: #f2f2f2;
        }
        /* styles.css */
        .chart-container {
            width: 80%;
            margin: 0 auto;
            padding: 20px;
        }
        .chart-container canvas { width: 80% ; height: auto ; }

        /* .histogram-container {
            width: 80%;
            margin: 0 auto;
            padding: 20px;
        }
        .histogram-container canvas { width: 80% ; height: auto ; } */
        table {
            margin: 0 auto;
            border-collapse: collapse;
        }

        table,
        th,
        td {
            border: 1px solid black;
        }
    </style>
    <!-- Import Chart.js v4.x -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
    <!-- Import chartjs-plugin-annotation for v3.x -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>

    <script src="https://cdn.jsdelivr.net/npm/date-fns@2.23.0/dist/date-fns.min.js"></script>
    <!-- Import chartjs-adapter-date-fns for v2.x -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>

</head>

<body>

    <h1>Practice Quiz Response Form</h1>
    <div class="top-section">
        <form id="inputForm" class="input-form">
            <div class="form-group">
                <label for="numQuestions">Number of Questions:</label>
                <input type="number" id="numQuestions" name="numQuestions" value="20">
            </div>
            <div class="form-group">
                <label for="numColumns">Number of Columns:</label>
                <input type="number" id="numColumns" name="numColumns" value="4">
            </div>
            <div class="form-group">
                <label for="startIndex">Starting Question Number:</label>
                <input type="number" id="startIndex" name="startIndex" value="1">
            </div>
            <div class="form-group">
                <label for="correctMarks">Marks for Correct:</label>
                <input type="number" id="correctMarks" name="correctMarks" value="2">
            </div>
            <div class="form-group">
                <label for="incorrectMarks">Marks for Incorrect:</label>
                <input type="number" id="incorrectMarks" name="incorrectMarks" value="1">
            </div>
            <div class="form-group">
                <label for="evalType">Evaluation Type:</label>
                <select id="evalType" name="evalType", class="custom-select">
                    <option value="Type-1" selected>Type-1</option>
                    <option value="Type-2">Type-2</option>
                </select>
            </div>
            <div class="form-group">
                <label for="subjectType">Subject:</label>
                <select id="subjectType" name="subjectType", class="custom-select">
                    <option value="Math" >Mathematics</option>
                    <option value="Reasoning">Reasoning</option>
                    <option value="English">English</option>
                    <option value="GK">GK</option>
                    <option value="Other" selected>Other</option>
                </select>
            </div>
            

            <div class="button-group">
                <button type="button" onclick="generateForm()">Get Form</button>
                <button type="button" onclick="submitForm()">Submit</button>
                <button type="button" onclick="performance()">Analyse</button>
                <button type="button" onclick="reset()">Reset</button>
                <button type="button" onclick="clearCache()">Clear</button>
            </div>
        </form>

        <div id="summary-button-container" class="summary-button-container" style="display: none;">
            <button id="summaryButton" onclick="showSummary()">Show Summary</button>
            <div id="summary" class="summary-container" style="display: none;"></div>
        </div>

        <div class="timer-container">
            <h1>Quiz Timer</h1>
            <div id="timer">00:00:00</div>
            <button id="startButton">Start</button>
            <button id="stopButton">Stop</button>
        </div>
    </div>
    <center>
        <div class="form-container-wrapper" id="formContainer-wrapper">
            <div class="form-container" id="formContainer"></div>
        </div>
    </center>
    <div id="result" class="result-container">
        <div id="your-response" class="your-response-container"></div>
        <div id="assessment" class="assessment-container"></div>
    </div>
    <div id="time-summary" class="time-summary-container" style="display: none;"></div>
    
    
    <div id="plotter" class="chart-container"></div>

    <script>
        // html handling section
        const analysisHTML =`
        <div id="timeAnalysis">
            <div class="new-form-group">
                <label for="statType">Statistical Measure:</label>
                <select id="statType" class="custom-select">
                    <option value="mean">Mean</option>
                    <option value="median">Median</option>
                    <option value="stdDev">Standard Deviation</option>
                    <option value="range">Range</option>
                    <option value="Q1">First Quartile (Q1)</option>
                    <option value="Q3">Third Quartile (Q3)</option>
                    <option value="IQR">Interquartile Range (IQR)</option>
                    <option value="kurtosis">Kurtosis</option>
                    <option value="skewness">Skewness</option>
                    <option value="b1">Skewness(b1)</option>
                    <option value="g1">Skewness(g1)</option>
                    <option value="scorePercentage">Score Percentage</option>
                </select>
            </div>
            <div class="new-form-group">
                <label for="subjectSelect">Subject:</label>
                <select id="subjectSelect" class="custom-select">
                    <option value="Math">Mathematics</option>
                    <option value="Reasoning">Reasoning</option>
                    <option value="English">English</option>
                    <option value="GK">GK</option>
                    <option value="Other">Other</option>
                </select>
            </div>
            <div class="new-form-group">
                <label for="responseType">Response Type:</label>
                <select id="responseType" class="custom-select">
                    <option value="all">All</option>
                    <option value="correct">Correct</option>
                    <option value="incorrect">Incorrect</option>
                    <option value="not_attempted">Not Attempted</option>
                </select>
            </div>
        
            <button class= "horizontal-buttons", onclick="plotPerformanceGraph()">Plot Graph</button>
            <div id="performanceChartContainer" class="chart-container"> 
                <canvas id="performanceChart"></canvas>
            </div>
        </div>
        `;
        const plotterHTML =`
        <div id="chart" class="chart-container">
            <canvas id="timeChart"></canvas>
        </div>
        <div id="histogram" class="chart-container">
            <canvas id="histogramChart"></canvas>
        </div>
        <div id="allChartContainer" class="chart-container"> 
            <canvas id="allChart"></canvas> 
        </div> 
        <div id="correctChartContainer" class="chart-container"> 
            <canvas id="correctChart"></canvas> 
        </div> 
        <div id="incorrectChartContainer" class="chart-container"> 
            <canvas id="incorrectChart"></canvas> 
        </div> 
        <div id="notAttemptedChartContainer" class="chart-container"> 
            <canvas id="notAttemptedChart"></canvas> 
        </div>
        ${analysisHTML}
        `;
        
        // General purpose
        let startTime;
        let timerInterval;
        let elapsedTime = parseInt(localStorage.getItem('elapsedTime'))||0;
        localStorage.setItem('elapsedTime',elapsedTime);
        let startFlag = (localStorage.getItem('startFlag')===true) || false;
        localStorage.setItem('startFlag',startFlag);

        let timeSpent = JSON.parse(localStorage.getItem('timeSpent')) || {};
        let history = {};
        // Chart Handling
        let timeChart, histogramChart,allChart,correctChart,incorrectChart,notAttemptedChart,performanceChart;

        let lastTimestamp;
        let numQuestions, numColumns, startIndex, correctMarks, incorrectMarks;

        // Local Storage Handling
        if(localStorage.getItem('numQuestions')){
            document.getElementById('numQuestions').value = localStorage.getItem('numQuestions');
            numQuestions = parseInt(localStorage.getItem('numQuestions'));
        }
        else numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
        
        if(localStorage.getItem('numColumns')){
            document.getElementById('numColumns').value = localStorage.getItem('numColumns');
            numColumns = parseInt(localStorage.getItem('numColumns'));
        }
        else numColumns = parseInt(document.getElementById('numColumns').value) || 4;

        if(localStorage.getItem('startIndex')){
            document.getElementById('startIndex').value = localStorage.getItem('startIndex');
            startIndex = parseInt(localStorage.getItem('startIndex'));
        }
        else startIndex = parseInt(document.getElementById('startIndex').value) || 1;

        if(localStorage.getItem('correctMarks')){
            document.getElementById('correctMarks').value = localStorage.getItem('correctMarks');
            correctMarks = parseInt(localStorage.getItem('correctMarks'));

        }
        else correctMarks = parseInt(document.getElementById('correctMarks').value) || 2;

        if(localStorage.getItem('incorrectMarks')){
            document.getElementById('incorrectMarks').value = localStorage.getItem('incorrectMarks');
            correctMarks = parseInt(localStorage.getItem('incorrectMarks'));
        }
        else incorrectMarks = parseInt(document.getElementById('incorrectMarks').value) || 1;

        // generateForm();
        // submitForm();
        // showSummary();

        document.getElementById('startButton').addEventListener('click', function() {
            
            if (!(localStorage.getItem('startFlag')==='true')) {
                generateForm();
            
                startFlag = true;
                localStorage.setItem('startFlag',startFlag);

                startTime = new Date(localStorage.getItem('startTime') || new Date());
                lastTimestamp = new Date(localStorage.getItem('lastTimestamp') || Date.now());
                timerInterval = setInterval(updateTimer, 1000);
                addEventListeners();

                localStorage.setItem('startTime', startTime.toISOString());
                localStorage.setItem('lastTimestamp', lastTimestamp.toString());

                if (localStorage.getItem('elapsedTime') !== null) {
                    elapsedTime = parseInt(localStorage.getItem('elapsedTime'));
                    // console.log("First loop when test is paused!");
                } else {
                    elapsedTime = 0;
                    localStorage.setItem('elapsedTime', 0);
                    // console.log("Elapsed Time here:", elapsedTime);
                    // console.log("Second loop when test is started!");
                }       

                console.log("Start Time:", startTime);
                console.log("Last Timestamp:", lastTimestamp);
                console.log("Elapsed Time:", elapsedTime);
            }
        });



        document.getElementById('stopButton').addEventListener('click', function() {
            clearInterval(timerInterval);
            
            if(localStorage.getItem('startTime')!==null){

                elapsedTime = elapsedTime + (new Date() - startTime);
                localStorage.setItem('elapsedTime',elapsedTime);

                updateTimer(0);
                startFlag = false;
                localStorage.setItem('startFlag',startFlag);

                localStorage.removeItem('lastTimestamp');
                localStorage.removeItem('startTime');
            }
                
            
        });
        function updateTimeSpent(questionNumber) {
            const currentTimestamp = Date.now();
            const timeDifference = currentTimestamp - lastTimestamp;

            // Update the time spent on the current question
            if(timeSpent[questionNumber]===null){
                timeSpent[questionNumber] += timeDifference;
            }
            else{
                timeSpent[questionNumber] = timeDifference;
            }

            // Update the last timestamp
            lastTimestamp = currentTimestamp;
            localStorage.setItem('lastTimestamp', lastTimestamp.toString());
            localStorage.setItem('timeSpent',JSON.stringify(timeSpent));
        }

        // Add event listeners to all radio buttons
        function addEventListeners() {
            const radioButtons = document.querySelectorAll('input[type="radio"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('click', (event) => {
                    const questionNumber = parseInt(event.target.name.split('-')[1]);
                    updateTimeSpent(questionNumber);
                });
            });
        }



        function updateTimer(flag = 1) {
            const currentTime = new Date();
            startTime = new Date(localStorage.getItem('startTime'));
            const elapsedTimeNow =  parseInt(localStorage.getItem('elapsedTime')) + flag*((currentTime - startTime));
            
            // console.log("Elapsed Time Now: ", elapsedTimeNow,"\n", 
            //             "elapsedTime:", elapsedTime,"\n", 
            //             "localStorage(elapsedTime):", parseInt(localStorage.getItem('elapsedTime')),"\n",
            //             "start Time:",startTime);

            const hours = Math.floor(elapsedTimeNow / (1000 * 60 * 60)) || 0;
            const minutes = Math.floor((elapsedTimeNow % (1000 * 60 * 60)) / (1000 * 60)) || 0;
            const seconds = Math.floor((elapsedTimeNow % (1000 * 60)) / 1000) || 0;
            document.getElementById('timer').textContent =
                `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
        }

        function pad(number) {
            return number < 10 ? '0' + number : number;
        }
        window.onload = function() {
            updateTimer(0);
            const savedNumQuestions = localStorage.getItem('numQuestions');
            const savedNumColumns = localStorage.getItem('numColumns');
            const savedStartIndex = localStorage.getItem('startIndex');
            const savedCorrect = localStorage.getItem('correctMarks');
            const savedIncorrect = localStorage.getItem('incorrectMarks');
            const incorrectSaved = localStorage.getItem('incorrectResponses');
            const notAttemptedSaved = localStorage.getItem('notAttemptedResponses');
            const evalType = document.getElementById('evalType') || 'Type-1';
            if (savedNumQuestions) {
                document.getElementById('numQuestions').value = savedNumQuestions;
            }
            if (savedNumColumns) {
                document.getElementById('numColumns').value = savedNumColumns;
            }
            if (savedStartIndex) {
                document.getElementById('startIndex').value = savedStartIndex;
            }
            if (savedCorrect) {
                document.getElementById('correctMarks').value = savedCorrect;

            }
            if (savedIncorrect) {
                document.getElementById('incorrectMarks').value = savedIncorrect;

            }
            // Add Saved Portion If required
            if(evalType==='Type-1'){

            }
            
            if(localStorage.getItem('startFlag_')==='true'){
                generateForm();        
                document.getElementById('startButton').click();
            }else{
                loadSelections();
            }


        };
        window.addEventListener('beforeunload', function (event) {
            // Your function or code to run
            if(localStorage.getItem('startFlag')==='true'){
                document.getElementById('stopButton').click();
                localStorage.setItem('startFlag_', true);
            }else{
                localStorage.setItem('startFlag_', false);
            }

            // Standard way to show a confirmation dialog (modern browsers may not honor this)
            event.preventDefault();
            event.returnValue = '';
        });

        function performance(){
            document.getElementById('plotter').innerHTML=analysisHTML;
        }

        function generateForm() {
            numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
            numColumns = parseInt(document.getElementById('numColumns').value) || 4;
            startIndex = parseInt(document.getElementById('startIndex').value) || 1;
            correctMarks = parseInt(document.getElementById('correctMarks').value) || 2;
            incorrectMarks = parseInt(document.getElementById('incorrectMarks').value) || 1;
            // Save number of questions and columns to local storage
            localStorage.setItem('numQuestions', numQuestions);
            localStorage.setItem('numColumns', numColumns);
            localStorage.setItem('startIndex', startIndex);
            localStorage.setItem('correctMarks', correctMarks);
            localStorage.setItem('incorrectMarks', incorrectMarks);
            
            // Hide the questions and options after submitting
            document.getElementById('result').style.display = 'none';
            document.getElementById('summary-button-container').style.display = 'none';
            document.getElementById('time-summary').style.display = 'none';
            document.getElementById('result').innerHTML = `<div id="result" class="result-container">
                <div id="your-response" class="your-response-container"></div>
                <div id="assessment" class="assessment-container"></div>
                </div>
                `;
                
                document.getElementById('formContainer-wrapper').style.display = 'inline-block';
                document.getElementById('plotter').innerHTML = '';
                // document.getElementById('chart').innerHTML =`<canvas id="timeChart"></canvas>`;

            const formContainer = document.getElementById('formContainer');
            formContainer.innerHTML = '';

            const form = document.createElement('form');
            form.className = 'form-container';

            const questionsPerColumn = Math.floor(numQuestions / numColumns);
            const remainder = numQuestions % numColumns;

            let questionNumber = startIndex;
            for (let col = 0; col < numColumns; col++) {
                const column = document.createElement('div');
                column.className = 'column';

                // Add the header row with A, B, C, D for each column
                const headerRow = document.createElement('div');
                headerRow.className = 'question-header';
                headerRow.innerHTML = `
                    <div class="radio-group">
                        <label class="radio-label">Q</label>
                        <label class="radio-label">A</label>
                        <label class="radio-label">B</label>
                        <label class="radio-label">C</label>
                        <label class="radio-label">D</label>
                    </div>
                `;
                column.appendChild(headerRow);

                const questionsInThisColumn = questionsPerColumn + (col < remainder ? 1 : 0);

                for (let i = 0; i < questionsInThisColumn; i++) {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    const questionText = "0".repeat((numQuestions + startIndex - 1).toString().length - questionNumber.toString().length) + questionNumber;
                    questionDiv.innerHTML = `
                        ${questionText}. 
                        <div class="radio-group">
                            <label class="radio-label"><input type="radio" name="q-${questionNumber}" value="A" onclick="handleSelection(${questionNumber}, 'A')"></label>
                            <label class="radio-label"><input type="radio" name="q-${questionNumber}" value="B" onclick="handleSelection(${questionNumber}, 'B')"></label>
                            <label class="radio-label"><input type="radio" name="q-${questionNumber}" value="C" onclick="handleSelection(${questionNumber}, 'C')"></label>
                            <label class="radio-label"><input type="radio" name="q-${questionNumber}" value="D" onclick="handleSelection(${questionNumber}, 'D')"></label>
                        </div>
                    `;
                    column.appendChild(questionDiv);
                    questionNumber++;
                }
                form.appendChild(column);
            }
            // Show the form
            formContainer.appendChild(form);
            loadSelections();

        }

        function handleSelection(questionNumber, option) {
            const numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
            const numColumns = parseInt(document.getElementById('numColumns').value) || 4;
            const startIndex = parseInt(document.getElementById('startIndex').value) || 1;

            const selectedOption = document.querySelector(`input[name="q-${questionNumber}"][value="${option}"]`);
            if (history.hasOwnProperty(questionNumber) && history[questionNumber]===option) {
                selectedOption.checked = false;
                localStorage.removeItem(`q-${questionNumber}`);
                history[questionNumber]= 'none';
            } else {
                selectedOption.checked = true;
                localStorage.setItem(`q-${questionNumber}`, option);
                history[questionNumber] = option;
            }
        }

        function loadSelections() {
            history = {};
            const numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
            const numColumns = parseInt(document.getElementById('numColumns').value) || 4;
            const startIndex = parseInt(document.getElementById('startIndex').value) || 1;
            const correctMarks = parseInt(document.getElementById('correctMarks').value) || 2;
            const incorrectMarks = parseInt(document.getElementById('incorrectMarks').value) || 1;

            timeSpent = JSON.parse(localStorage.getItem('timeSpent')) || {};
            for (let i = 0; i < numQuestions; i++) {
                const savedOption = localStorage.getItem(`q-${i+startIndex}`);
                if (savedOption) {
                    const radioButton = document.querySelector(`input[name="q-${i+startIndex}"][value="${savedOption}"]`);
                    if (radioButton) {
                        radioButton.checked = true;
                        history[i+startIndex] = savedOption;
                    }
                }
            }
        }
        function clearCache(){
            localStorage.clear();
        }
        function reset() {
            // Retrieve and store the statistical data
            const statisticsData = JSON.parse(localStorage.getItem('statisticsData'));

            // Clear all local storage
            localStorage.clear();

            // Restore the statistical data
            if (statisticsData) {
                localStorage.setItem('statisticsData', JSON.stringify(statisticsData));
            }

            // Clear other data and reset UI elements
            clearInterval(timerInterval);
            history = {};
            document.getElementById('formContainer-wrapper').style.display = 'none';
            document.getElementById('result').style.display = 'none';
            document.getElementById('summary-button-container').style.display = 'none';
            // document.getElementById('chart').innerHTML = `<canvas id="timeChart"></canvas>`;
            document.getElementById('time-summary').style.display = 'none';
            document.getElementById('timer').textContent = `${pad(0)}:${pad(0)}:${pad(0)}`;
            document.getElementById("plotter").innerHTML = '';
        }


        // Handle form submission
        function submitForm() {
            // Trigger the stop button click event
            document.getElementById('stopButton').click();
            const questions = document.querySelectorAll('.question');
            
            // Set display style for all elements with the class 'result-container'
            const resultContainers = document.getElementsByClassName('result-container');
            for (let i = 0; i < resultContainers.length; i++) {
                resultContainers[i].style.display = 'flex';
            }

            const startIndex = parseInt(document.getElementById('startIndex').value) || 1;
            const numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
            let resultHTML = '<center><h2>Your Responses</h2></center><table class="response-table left-align" border="1" style="border-collapse: collapse;"><tr>';
            questions.forEach((question, index) => {
                const questionNumber = index + startIndex;
                const questionText = "0".repeat((numQuestions + startIndex - 1).toString().length - (questionNumber).toString().length);
                const selectedOption = question.querySelector('input[type="radio"]:checked');
                const response = selectedOption ? selectedOption.value : '*';
                resultHTML += `<td>${questionText}${questionNumber}. (${response})</td>`;

                // Create a new row after every 4 columns
                if ((index + 1) % 4 === 0) {
                    resultHTML += '</tr><tr>';
                }

            });

            resultHTML += '</tr></table>';
            document.getElementById('your-response').innerHTML = resultHTML;
            // Hide the questions and options after submitting
            document.getElementById('formContainer-wrapper').style.display = 'none';

            // Display the result with tick and cross options
            const resultContainer = document.getElementById('assessment');
            const resultHeader = '<h2> Assessment</h2>'+'<p>'.repeat(4);
            resultContainer.innerHTML = resultHeader;


            function getType1Form() {
                const row = numQuestions/4+2;
                const col = 30;
                resultContainer.innerHTML+= `
                    
                    <div>
                        <label for="incorrectResponses">Incorrect Responses:</label>
                        <textarea id="incorrectResponses" name="incorrectResponses" rows="${row}" cols="${col}" placeholder="Enter incorrect responses here..."></textarea>
                    </div>
                    <div>
                        <label for="notAttemptedResponses">Not Attempted Responses:</label>
                        <textarea id="notAttemptedResponses" name="notAttemptedResponses" rows="${row}" cols="${col}" placeholder="Enter not attempted responses here..."></textarea>
                    </div>
                `;
               
                // Need to write code for local storage
                // Add event listeners to save the content to localStorage 
                document.getElementById('incorrectResponses').addEventListener('input', function() { 
                    localStorage.setItem('incorrectResponses', this.value); 
                }); 
                document.getElementById('notAttemptedResponses').addEventListener('input', function() { 
                    localStorage.setItem('notAttemptedResponses', this.value);
                });

                const incorrectSaved = localStorage.getItem('incorrectResponses');
                const notAttemptedSaved = localStorage.getItem('notAttemptedResponses');
                if(incorrectSaved){
                    document.getElementById('incorrectResponses').value = incorrectSaved;
                }
                if(notAttemptedSaved){
                    document.getElementById('notAttemptedResponses').value = notAttemptedSaved;
                }
            }

            function getType2Form(){
                for (let i = 1; i <= numQuestions; i++) {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'result-item';
                    const questionText = "0".repeat((numQuestions + startIndex - 1).toString().length - (i+startIndex-1).toString().length);
                    const label = document.createElement('label');
                    label.textContent = `${questionText}${i+startIndex-1}.`;
                    resultItem.appendChild(label);
                    const correctRadio = document.createElement('input');
                    correctRadio.type = 'radio';
                    correctRadio.name = `question-${i + startIndex-1}`;
                    correctRadio.className = 'correct';
                    correctRadio.title = 'Correct';
                    correctRadio.addEventListener('click', function() { 
                        if(localStorage.getItem(`response-${i + startIndex - 1}`)==='correct'){
                            localStorage.removeItem(`response-${i + startIndex - 1}`);
                            correctRadio.checked = false;
                        } else
                            localStorage.setItem(`response-${i+startIndex-1}`, 'correct');
                    });
                    resultItem.appendChild(correctRadio);

                    const incorrectRadio = document.createElement('input');
                    incorrectRadio.type = 'radio';
                    incorrectRadio.name = `question-${i + startIndex-1}`;
                    incorrectRadio.className = 'incorrect';
                    incorrectRadio.title = 'Incorrect';
                    incorrectRadio.addEventListener('click', function() {  
                        if(localStorage.getItem(`response-${i + startIndex - 1}`)==='incorrect'){
                            localStorage.removeItem(`response-${i + startIndex - 1}`);
                            incorrectRadio.checked = false;
                        } else
                            localStorage.setItem(`response-${i+startIndex-1}`, 'incorrect');

                    });
                    resultItem.appendChild(incorrectRadio);

                    // Load the saved state 
                    const savedResponse = localStorage.getItem(`response-${i + startIndex - 1}`); 
                    if (savedResponse === 'correct') { 
                        correctRadio.checked = true; 
                    } else if (savedResponse === 'incorrect') { 
                        incorrectRadio.checked = true; 
                    }
                    resultContainer.appendChild(resultItem);
                }
            }
            const evalType =  document.getElementById('evalType').value || "Type-1";
            if(evalType==='Type-1'){
                getType1Form();
            }
            else{
                getType2Form();
            }

            
            
            
            // Show the summary button after submission
            document.getElementById('summary').style.display = 'none';
            document.getElementById('summaryButton').style.display='block';
            document.getElementById('summary-button-container').style.display = 'block';

           
            for (let i = 0; i < numQuestions; i++) {
                if(!timeSpent.hasOwnProperty(i+startIndex))
                    timeSpent[i+startIndex] = 0;
            }
            localStorage.setItem('timeSpent',JSON.stringify(timeSpent));
            
            
        }
        function splitAndCastToInt(text) {
            // Split the text by comma and spaces using regex and filter out empty strings
            // text += ",";
            let arr = text.split(/[, ]+/).filter(Boolean);

            // Cast each element to an integer and store in a new array
            console.log(text);
            console.log(arr.map(Number));
            return arr.map(Number);

        }

        function getEvaluation(){
            const correctMarks = parseInt(document.getElementById('correctMarks').value) || 2;
            const incorrectMarks = parseInt(document.getElementById('incorrectMarks').value) || 1;
            const totalQuestions = parseInt(localStorage.getItem('numQuestions')) ;
            const evalType =  document.getElementById('evalType').value || "Type-1";

            let correct_answers,wrong_answers,notAttempted;
            if(evalType==='Type-1'){
                const incorrectResponses = document.getElementById('incorrectResponses').value ||"";
                const notAttemptedResponses = document.getElementById('notAttemptedResponses').value || "";

                wrong_answers = splitAndCastToInt(incorrectResponses).length;
                notAttempted = splitAndCastToInt(notAttemptedResponses).length;
                correct_answers = totalQuestions - (notAttempted+wrong_answers);

            }
            else{

                const correctRadios = document.querySelectorAll('.correct:checked');
                const incorrectRadios = document.querySelectorAll('.incorrect:checked');
    
                correct_answers = correctRadios.length;
                wrong_answers = incorrectRadios.length;
                notAttempted = totalQuestions - (correct_answers+wrong_answers);

            }
            const total_correctMarks = correctMarks*correct_answers;
            const total_incorrectMarks = incorrectMarks*wrong_answers;
            const marks = total_correctMarks-total_incorrectMarks;
            const total_marks = correctMarks*totalQuestions;

            const correct_percent = ((correct_answers/totalQuestions*100)).toFixed(2);
            const incorrect_percent = ((wrong_answers/totalQuestions*100)).toFixed(2);
            const notAttempted_percent = ((notAttempted/totalQuestions*100)).toFixed(2);
            const marks_percent = ((marks/total_marks*100)).toFixed(2);
            return {correct_answers, wrong_answers, notAttempted, 
                marks, total_correctMarks, total_incorrectMarks, total_marks,
                correct_percent, incorrect_percent, notAttempted_percent, marks_percent
             };
        }
        function showSummary() {
            
            const evaluation = getEvaluation();

            console.log(`No of Correct: ${evaluation.correct_answers}\nNo of Incorrrect: ${evaluation.wrong_answers}\nNo of Not Attempted: ${evaluation.notAttempted}`);
            
            const summaryHTML = `<h2>Summary</h2><table class="summary-table">
            <tr>
                <th>Category</th>
                <th>Count</th>
            </tr>
            <tr>
                <td>Correct</td>
                <td>${evaluation.correct_answers} (${evaluation.correct_percent}%)</td>
            </tr>
            <tr>
                <td>Incorrect</td>
                <td>${evaluation.wrong_answers} (${evaluation.incorrect_percent}%)</td>
            </tr>
            <tr>
                <td>Not Attempted</td>
                <td>${evaluation.notAttempted} (${evaluation.notAttempted_percent}%)</td>
            </tr>
            <tr>
                <td>Marks</td>
                <td>${evaluation.marks} (${evaluation.marks_percent}%)</td>
            </tr>
        </table>
            `;

            const summaryContainer = document.getElementById('summary');
            summaryContainer.innerHTML = summaryHTML;
            summaryContainer.style.display = 'block';
            document.getElementById('summaryButton').style.display='none';

            document.getElementById('plotter').innerHTML = plotterHTML;

            const timeSummaryContainer = document.getElementById('time-summary');
            timeSummaryContainer.style.display = 'block';
            document.getElementById('chart').style.display = 'block';
            document.getElementById('subjectSelect').value = document.getElementById('subjectType').value;
            createGraph();
        }
        // Storing the value
        function storeStatistics(stats, subType,dateTime) {
            // const dateTime = new Date().toISOString();
            const key = 'statisticsData';

            // Retrieve existing data from localStorage
            let storedData = JSON.parse(localStorage.getItem(key)) || {};
            const subject = document.getElementById('subjectType').value;
            // Initialize subject data if it doesn't exist
            if (!storedData[subject]) {
                storedData[subject] = {};
            }

            // Store stats in subject data
            for (const [stat, value] of Object.entries(stats)) {
                const second_key = `${subType}_${stat}`;
                if (!storedData[subject][second_key]) {
                    storedData[subject][second_key] = {};
                }
                storedData[subject][second_key][dateTime] = value;
            }

            // Save the updated data back to localStorage
            localStorage.setItem(key, JSON.stringify(storedData));
        }

        function calculateStatistics(times) {
            if (times.length === 0) {
                const mean = 0;
                const median = 0;
                const stdDev = 0;
                const meanDev = 0; 
                const medianDev = 0;
                const range = 0;
                const Q1 = 0;
                const Q3 = 0;
                const IQR = 0;
                const kurtosis = 0;
                const skewness = 0;
                const b1 = 0;
                const g1 = 0;
                return { mean, median, stdDev, meanDev, medianDev, range, Q1, Q3, IQR, skewness, kurtosis, b1, g1,};
            }

            const mean = times.reduce((a, b) => a + b, 0) / times.length;
            const sortedTimes = times.slice().sort((a, b) => a - b); // Sort the times

            const median = sortedTimes[Math.floor(times.length / 2)];
            const stdDev = Math.sqrt(times.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / times.length);
            const meanDev = times.map(x => Math.abs(x - mean)).reduce((a, b) => a + b, 0) / times.length;
            const medianDev = times.map(x => Math.abs(x - median)).reduce((a, b) => a + b, 0) / times.length;
            const cv = stdDev / mean * 100;

            // Range
            const range = sortedTimes[sortedTimes.length - 1] - sortedTimes[0];

            // First Quartile (Q1)
            const Q1 = sortedTimes[Math.floor(times.length / 4)];

            // Third Quartile (Q3)
            const Q3 = sortedTimes[Math.floor(3 * times.length / 4)];

            // Interquartile Range (IQR)
            const IQR = Q3 - Q1;

            // Skewness
            const skewness = (times.length / ((times.length - 1) * (times.length - 2))) *
                times.map(x => Math.pow((x - mean) / stdDev, 3)).reduce((a, b) => a + b, 0);

            // Kurtosis
            const kurtosis = (times.length * (times.length + 1) / ((times.length - 1) * (times.length - 2) * (times.length - 3))) *
                times.map(x => Math.pow((x - mean) / stdDev, 4)).reduce((a, b) => a + b, 0) -
                (3 * Math.pow(times.length - 1, 2) / ((times.length - 2) * (times.length - 3)));
            
            const m3 = times.map(x => Math.pow(x - mean, 3)).reduce((a, b) => a + b, 0) / times.length;
            const s = Math.sqrt(times.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / (times.length-1));;
            const b1 = m3/Math.pow(s,3); 
            const g1 = m3/Math.pow(stdDev,3);
            console.log(mean, median, stdDev, meanDev, medianDev, range, Q1, Q3, IQR, skewness, kurtosis, b1, g1);
            return { mean, median, stdDev, meanDev, medianDev, range, Q1, Q3, IQR, skewness, kurtosis, b1, g1 };
        }

        function displayStatisticsTable(allStats, correctStats, incorrectStats, notAttemptedStats) {
            const table = `<h2>Statistics of Result</h2>
                <table border="1">
                    <tr>
                        <th>Category</th>
                        <th>Mean (s)</th>
                        <th>Median (s)</th>
                        <th>Q1 (s)</th>
                        <th>Q3 (s)</th>
                        <th>IQR (s)</th>
                        <th>Range (s)</th>
                        <th>Mean Deviation (s)</th>
                        <th>Median Deviation (s)</th>
                        <th>Standard Deviation (s)</th>
                        <th>Skewness</th>
                        <th>Kurtosis</th>
                        <th>b1</th>
                        <th>g1</th>
                    </tr>
                    <tr>
                        <td>All</td>
                        <td>${allStats.mean.toFixed(2)}</td>
                        <td>${allStats.median.toFixed(2)}</td>
                        <td>${allStats.Q1.toFixed(2)}</td>
                        <td>${allStats.Q3.toFixed(2)}</td>
                        <td>${allStats.IQR.toFixed(2)}</td>
                        <td>${allStats.range.toFixed(2)}</td>
                        <td>${allStats.meanDev.toFixed(2)}</td>
                        <td>${allStats.medianDev.toFixed(2)}</td>
                        <td>${allStats.stdDev.toFixed(2)}</td>
                        <td>${allStats.skewness.toFixed(2)}</td>
                        <td>${allStats.kurtosis.toFixed(2)}</td>
                        <td>${allStats.b1.toFixed(2)}</td>
                        <td>${allStats.g1.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Correct</td>
                        <td>${correctStats.mean.toFixed(2)}</td>
                        <td>${correctStats.median.toFixed(2)}</td>
                        <td>${correctStats.Q1.toFixed(2)}</td>
                        <td>${correctStats.Q3.toFixed(2)}</td>
                        <td>${correctStats.IQR.toFixed(2)}</td>
                        <td>${correctStats.range.toFixed(2)}</td>
                        <td>${correctStats.meanDev.toFixed(2)}</td>
                        <td>${correctStats.medianDev.toFixed(2)}</td>
                        <td>${correctStats.stdDev.toFixed(2)}</td>
                        <td>${correctStats.skewness.toFixed(2)}</td>
                        <td>${correctStats.kurtosis.toFixed(2)}</td>
                        <td>${correctStats.b1.toFixed(2)}</td>
                        <td>${correctStats.g1.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Incorrect</td>
                        <td>${incorrectStats.mean.toFixed(2)}</td>
                        <td>${incorrectStats.median.toFixed(2)}</td>
                        <td>${incorrectStats.Q1.toFixed(2)}</td>
                        <td>${incorrectStats.Q3.toFixed(2)}</td>
                        <td>${incorrectStats.IQR.toFixed(2)}</td>
                        <td>${incorrectStats.range.toFixed(2)}</td>
                        <td>${incorrectStats.meanDev.toFixed(2)}</td>
                        <td>${incorrectStats.medianDev.toFixed(2)}</td>
                        <td>${incorrectStats.stdDev.toFixed(2)}</td>
                        <td>${incorrectStats.skewness.toFixed(2)}</td>
                        <td>${incorrectStats.kurtosis.toFixed(2)}</td>
                        <td>${incorrectStats.b1.toFixed(2)}</td>
                        <td>${incorrectStats.g1.toFixed(2)}</td>
                    </tr>
                    <tr>
                        <td>Not Attempted</td>
                        <td>${notAttemptedStats.mean.toFixed(2)}</td>
                        <td>${notAttemptedStats.median.toFixed(2)}</td>
                        <td>${notAttemptedStats.Q1.toFixed(2)}</td>
                        <td>${notAttemptedStats.Q3.toFixed(2)}</td>
                        <td>${notAttemptedStats.IQR.toFixed(2)}</td>
                        <td>${notAttemptedStats.range.toFixed(2)}</td>
                        <td>${notAttemptedStats.meanDev.toFixed(2)}</td>
                        <td>${notAttemptedStats.medianDev.toFixed(2)}</td>
                        <td>${notAttemptedStats.stdDev.toFixed(2)}</td>
                        <td>${notAttemptedStats.skewness.toFixed(2)}</td>
                        <td>${notAttemptedStats.kurtosis.toFixed(2)}</td>
                        <td>${notAttemptedStats.b1.toFixed(2)}</td>
                        <td>${notAttemptedStats.g1.toFixed(2)}</td>
                    </tr>
                </table>
            `;
            document.getElementById('time-summary').innerHTML = table;
        }

        function createGraph(){
            let timeSpent = JSON.parse(localStorage.getItem('timeSpent')) || {};
            const startIndex = parseInt(document.getElementById('startIndex').value) || 1;
            const numQuestions = parseInt(document.getElementById('numQuestions').value) || 20;
            const evalType =  document.getElementById('evalType').value || "Type-1";

            const timeSpents = {};
            for(let i = 1; i <= numQuestions; i++){
                const questionNumber = i + startIndex - 1;
                timeSpents [questionNumber] = timeSpent[questionNumber]/1000;
            }

           
            const responses = {};
            if(evalType==='Type-1'){
                for (let i = 1; i <= numQuestions; i++) {
                    const questionNumber = i + startIndex - 1;
                    responses[questionNumber] = 'correct';
                }
                const incorrectResponses = document.getElementById('incorrectResponses').value ||"";
                const notAttemptedResponses = document.getElementById('notAttemptedResponses').value || "";
                const getIncorrect = splitAndCastToInt(incorrectResponses);
                const getNotAttempted = splitAndCastToInt(notAttemptedResponses);
                getIncorrect.forEach(num => {
                    responses[num] = 'incorrect';
                })
                getNotAttempted.forEach(num => {
                    responses[num] = 'not_attempted';
                })
            }
            else {

                for (let i = 1; i <= numQuestions; i++) {
                    const questionNumber = i + startIndex - 1;
                    const correctRadio = document.querySelector(`input[name="question-${questionNumber}"].correct`);
                    const incorrectRadio = document.querySelector(`input[name="question-${questionNumber}"].incorrect`);
    
                    if (correctRadio.checked) {
                        responses[questionNumber] = 'correct';
                    } else if (incorrectRadio.checked) {
                        responses[questionNumber] = 'incorrect';
                    } else {
                        responses[questionNumber] = 'not_attempted';
                    }
                }

            }

            const allTimes = Object.values(timeSpents);
            const correctTimes = Object.keys(timeSpents).filter(key => responses[key] === 'correct').map(key => timeSpents[key]);
            const incorrectTimes = Object.keys(timeSpents).filter(key => responses[key] === 'incorrect').map(key => timeSpents[key]);
            const notAttemptedTimes = Object.keys(timeSpents).filter(key => responses[key] === 'not_attempted').map(key => timeSpents[key]);

            const allStats = calculateStatistics(allTimes);
            const correctStats = calculateStatistics(correctTimes);
            const incorrectStats = calculateStatistics(incorrectTimes);
            const notAttemptedStats = calculateStatistics(notAttemptedTimes);

            const evaluation = getEvaluation();
            allStats.scorePercentage = evaluation.marks_percent;
            correctStats.scorePercentage = evaluation.correct_percent;
            incorrectStats.scorePercentage = evaluation.incorrect_percent;
            notAttemptedStats.scorePercentage = evaluation.notAttempted;
            // const today = new Date();
            // const dayAfterTomorrow = new Date(today);
            // dayAfterTomorrow.setDate(today.getDate() + 2);
            // console.log(dayAfterTomorrow,today);
            const dateTime = new Date().toISOString();
            const subject = document.getElementById('subjectType').value; 
            storeStatistics(allStats, 'all', dateTime); 
            storeStatistics(correctStats, 'correct', dateTime); 
            storeStatistics(incorrectStats, 'incorrect', dateTime); 
            storeStatistics(notAttemptedStats, 'not_attempted', dateTime);

            // Display the statistics in a table
            displayStatisticsTable(allStats, correctStats, incorrectStats, notAttemptedStats);

            // Prepare data for the chart
            const correct_data =  Object.keys(responses).filter(key =>responses[key]=='correct').map(val =>({x:val,y:timeSpents[val.toString()]}) );
            const incorrect_data =  Object.keys(responses).filter(key =>responses[key]=='incorrect').map(val =>({x:val,y:timeSpents[val.toString()]}) );
            const notAttempted_data =  Object.keys(responses).filter(key =>responses[key]=='not_attempted').map(val =>({x:val,y:timeSpents[val.toString()]}) );
            
            // Create the chart
            const ctx = document.getElementById('timeChart').getContext('2d');
            
            if (timeChart) { timeChart.destroy();}

            timeChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    labels: Object.keys(timeSpents),
                    datasets: [
                        {
                            label: 'All',
                            data: Object.keys(timeSpents).map((label, index) => ({ 
                                x: label, y: timeSpents[label.toString()] 
                            })),
                            backgroundColor: Object.keys(timeSpents).map(label => {
                                            if (responses[label] === 'correct') return 'green';
                                            if (responses[label] === 'incorrect') return 'red';
                                            return 'grey'; 
                                            // Not Working for Github pages
                                        }),
                            legendColor: 'royalblue',
                            pointRadius: 5,
                        },
                        {
                            label: 'Correct',
                            data: correct_data,
                            backgroundColor: 'green',
                            pointRadius: 5,
                            hidden: true,
                        },
                        {
                            label: 'Incorrect',
                            data: incorrect_data,
                            backgroundColor: 'red',
                            pointRadius: 5,
                            hidden: true,
                        },
                        {
                            label: 'Not Attempted',
                            data: notAttempted_data,
                            backgroundColor: 'grey',
                            pointRadius: 5,
                            hidden: true,
                        },
                        {
                            label: 'Mean Lines', // Add this dataset for the annotations
                            data: [], // Empty data for the annotations
                            backgroundColor: 'orange',
                            hidden: false, // Show by default
                            // click: (ctx) =>{
                            //     ctx.chart.update();
                            // } 
                        },
                        {
                            label: 'Median Lines', // Add this dataset for the annotations
                            data: [], // Empty data for the annotations
                            backgroundColor: 'brown',
                            hidden: false // Show by default
                        },
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'Question Number'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Time Spent (seconds)'
                            }
                        }
                    },
                    plugins: {
                        // custom_annotation: true,
                        annotation: {
                            annotations: {
                                // Line for All Options
                                meanLine_0: {
                                    type: 'line',
                                    yMin: allStats.mean,
                                    yMax: allStats.mean,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    // display: true,
                                },
                                upperStdDevLine_0: {
                                    type: 'line',
                                    yMin: allStats.mean + 3 * allStats.stdDev,
                                    yMax: allStats.mean + 3 * allStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean + 3*SD',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: true,
                                },
                                lowerStdDevLine_0: {
                                    type: 'line',
                                    yMin: allStats.mean - 3 * allStats.stdDev,
                                    yMax: allStats.mean - 3 * allStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean - 3*SD',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    // display: true,
                                },
                                lowerIQRLine_0: { 
                                    type: 'line', 
                                    yMin: allStats.Q1 - 1.5 * allStats.IQR, 
                                    yMax: allStats.Q1 - 1.5 * allStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q1 - 1.5*IQR', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true,
                                    },
                                    // display: true,
                                }, 
                                upperIQRLine_0: { 
                                    type: 'line', 
                                    yMin: allStats.Q3 + 1.5 * allStats.IQR, 
                                    yMax: allStats.Q3 + 1.5 * allStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q3 + 1.5*IQR', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true, 
                                    },
                                    // display: true
                                }, 
                                medianLine_0: { 
                                    type: 'line', 
                                    yMin: allStats.median, 
                                    yMax: allStats.median, 
                                    borderColor: 'purple', 
                                    borderWidth: 2,
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Median', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true, 
                                    },
                                    // display: true,
                                },
                                // Line for Correct Options
                                meanLine_1: {
                                    type: 'line',
                                    yMin: correctStats.mean,
                                    yMax: correctStats.mean,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean (Correct)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                upperStdDevLine_1: {
                                    type: 'line',
                                    yMin: correctStats.mean + 3 * correctStats.stdDev,
                                    yMax: correctStats.mean + 3 * correctStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean + 3*SD (Correct)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerStdDevLine_1: {
                                    type: 'line',
                                    yMin: correctStats.mean - 3 * correctStats.stdDev,
                                    yMax: correctStats.mean - 3 * correctStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean - 3*SD (Correct)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerIQRLine_1: { 
                                    type: 'line', 
                                    yMin: correctStats.Q1 - 1.5 * correctStats.IQR, 
                                    yMax: correctStats.Q1 - 1.5 * correctStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q1 - 1.5*IQR (Correct)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                }, 
                                upperIQRLine_1: { 
                                    type: 'line', 
                                    yMin: correctStats.Q3 + 1.5 * correctStats.IQR, 
                                    yMax: correctStats.Q3 + 1.5 * correctStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q3 + 1.5*IQR (Correct)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                }, 
                                medianLine_1: { 
                                    type: 'line', 
                                    yMin: correctStats.median, 
                                    yMax: correctStats.median, 
                                    borderColor: 'purple', 
                                    borderWidth: 2,
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Median (Correct)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                },
                                // Line for Incorrect Options
                                meanLine_2: {
                                    type: 'line',
                                    yMin: incorrectStats.mean,
                                    yMax: incorrectStats.mean,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean (Incorrect)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                upperStdDevLine_2: {
                                    type: 'line',
                                    yMin: incorrectStats.mean + 3 * incorrectStats.stdDev,
                                    yMax: incorrectStats.mean + 3 * incorrectStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean + 3*SD (Incorrect)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerStdDevLine_2: {
                                    type: 'line',
                                    yMin: incorrectStats.mean - 3 * incorrectStats.stdDev,
                                    yMax: incorrectStats.mean - 3 * incorrectStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean - 3*SD (Incorrect)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerIQRLine_2: { 
                                    type: 'line', 
                                    yMin: incorrectStats.Q1 - 1.5 * incorrectStats.IQR, 
                                    yMax: incorrectStats.Q1 - 1.5 * incorrectStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q1 - 1.5*IQR (Incorrect)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                }, 
                                upperIQRLine_2: { 
                                    type: 'line', 
                                    yMin: incorrectStats.Q3 + 1.5 * incorrectStats.IQR, 
                                    yMax: incorrectStats.Q3 + 1.5 * incorrectStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q3 + 1.5*IQR (Incorrect)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                }, 
                                medianLine_2: { 
                                    type: 'line', 
                                    yMin: incorrectStats.median, 
                                    yMax: incorrectStats.median, 
                                    borderColor: 'purple', 
                                    borderWidth: 2,
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Median (Incorrect)', 
                                        enabled: true, 
                                        position: 'end' ,
                                        display: true,
                                    },
                                    display: false,
                                },
                                // Line for Not Attempted
                                meanLine_3: {
                                    type: 'line',
                                    yMin: notAttemptedStats.mean,
                                    yMax: notAttemptedStats.mean,
                                    borderColor: 'blue',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean (NA)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                upperStdDevLine_3: {
                                    type: 'line',
                                    yMin: notAttemptedStats.mean + 3 * notAttemptedStats.stdDev,
                                    yMax: notAttemptedStats.mean + 3 * notAttemptedStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean + 3*SD (NA)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerStdDevLine_3: {
                                    type: 'line',
                                    yMin: notAttemptedStats.mean - 3 * notAttemptedStats.stdDev,
                                    yMax: notAttemptedStats.mean - 3 * notAttemptedStats.stdDev,
                                    borderColor: 'orange',
                                    borderWidth: 2,
                                    label: {
                                        content: 'Mean - 3*SD (NA)',
                                        enabled: true,
                                        position: 'start',
                                        display: true,
                                    },
                                    display: false,
                                },
                                lowerIQRLine_3: { 
                                    type: 'line', 
                                    yMin: notAttemptedStats.Q1 - 1.5 * notAttemptedStats.IQR, 
                                    yMax: notAttemptedStats.Q1 - 1.5 * notAttemptedStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q1 - 1.5*IQR (NA)', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true,
                                    },
                                    display: false,
                                }, 
                                upperIQRLine_3: { 
                                    type: 'line', 
                                    yMin: notAttemptedStats.Q3 + 1.5 * notAttemptedStats.IQR, 
                                    yMax: notAttemptedStats.Q3 + 1.5 * notAttemptedStats.IQR, 
                                    borderColor: 'brown', 
                                    borderWidth: 2, 
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Q3 + 1.5*IQR (NA)', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true, 
                                    },
                                    display: false,
                                }, 
                                medianLine_3: { 
                                    type: 'line', 
                                    yMin: notAttemptedStats.median, 
                                    yMax: notAttemptedStats.median, 
                                    borderColor: 'purple', 
                                    borderWidth: 2,
                                    borderDash: [10, 5], 
                                    label: { 
                                        content: 'Median (NA)', 
                                        enabled: true, 
                                        position: 'end',
                                        display: true, 
                                    },
                                    display: false,
                                },
                            }
                        },
                        
                        legend: {
                            display: true,
                            position: 'top',
                            // onHover: ()=> {
                            //     console.log("hovering");
                            // },
                            onClick: (e, legendItem, legend) =>{
                                    const index = legendItem.datasetIndex;
                                    
                                    const ci = legend.chart;
                                    if( index < 4 ){
                                        
                                        if(ci.isDatasetVisible(index)){
                                            legendItem.hidden = true;
                                            ci.hide(index);
                                            ci.options.plugins.annotation.annotations[`meanLine_${index}`].display = false;
                                            ci.options.plugins.annotation.annotations[`upperStdDevLine_${index}`].display = false;
                                            ci.options.plugins.annotation.annotations[`lowerStdDevLine_${index}`].display = false;
                                            // so on
                                            ci.options.plugins.annotation.annotations[`medianLine_${index}`].display = false;
                                            ci.options.plugins.annotation.annotations[`upperIQRLine_${index}`].display = false;
                                            ci.options.plugins.annotation.annotations[`lowerIQRLine_${index}`].display = false;
                                        }
                                        else{
                                            legendItem.hidden = false;
                                            ci.show(index);
                                            // for(let i=0;i<4;i++){
                                            //     ci.options.plugins.annotation.annotations[`meanLine_${i}`].display = false;
                                            //     ci.options.plugins.annotation.annotations[`upperStdDevLine_${i}`].display = false;
                                            //     ci.options.plugins.annotation.annotations[`lowerStdDevLine_${i}`].display = false;
                                            //     // so on
                                            //     ci.options.plugins.annotation.annotations[`medianLine_${i}`].display = false;
                                            //     ci.options.plugins.annotation.annotations[`upperIQRLine_${i}`].display = false;
                                            //     ci.options.plugins.annotation.annotations[`lowerIQRLine_${i}`].display = false;
                                            // }
                                            ci.options.plugins.annotation.annotations[`meanLine_${index}`].display = ci.isDatasetVisible(4);
                                            ci.options.plugins.annotation.annotations[`upperStdDevLine_${index}`].display = ci.isDatasetVisible(4);;
                                            ci.options.plugins.annotation.annotations[`lowerStdDevLine_${index}`].display = ci.isDatasetVisible(4);;
                                            // so on
                                            ci.options.plugins.annotation.annotations[`medianLine_${index}`].display = ci.isDatasetVisible(5);;
                                            ci.options.plugins.annotation.annotations[`upperIQRLine_${index}`].display = ci.isDatasetVisible(5);;
                                            ci.options.plugins.annotation.annotations[`lowerIQRLine_${index}`].display = ci.isDatasetVisible(5);;
                                        }
                                    }
                                    else{
                                        let di;
                                        for(let i=0;i<4;i++){
                                            if(ci.isDatasetVisible(i)) {
                                                di = i;
                                                console.log("di: ",di,"State: ", ci.data.datasets[i].hidden);
                                                if(index===4){
                                                    ci.options.plugins.annotation.annotations[`meanLine_${di}`].display = !ci.isDatasetVisible(index);
                                                    ci.options.plugins.annotation.annotations[`upperStdDevLine_${di}`].display = !ci.isDatasetVisible(index);
                                                    ci.options.plugins.annotation.annotations[`lowerStdDevLine_${di}`].display = !ci.isDatasetVisible(index);
                                                    
                                                }
                                                if(index===5){
                                                    ci.options.plugins.annotation.annotations[`medianLine_${di}`].display = !ci.isDatasetVisible(index);
                                                    ci.options.plugins.annotation.annotations[`upperIQRLine_${di}`].display = !ci.isDatasetVisible(index);
                                                    ci.options.plugins.annotation.annotations[`lowerIQRLine_${di}`].display = !ci.isDatasetVisible(index);
                                                }
                                            }
                                        }
                                        
                                        if(ci.isDatasetVisible(index)){ 
                                            ci.hide(index);
                                            legendItem.hidden = true;
                                        }
                                        else {
                                            ci.show(index);
                                            legendItem.hidden = false;
                                        }
                                    }
                                    // if (ci.isDatasetVisible(index)) {
                                    //     ci.hide(index);
                                    //     legendItem.hidden = true;
                                    //     if(index===4){
                                    //         ci.options.plugins.annotation.annotations['meanLine'].display = false;
                                    //     }
                                    //     else{console.log("index not 4");}
                                    // } else {
                                    //     ci.show(index);
                                    //     legendItem.hidden = false;
                                    //     if(index===4){
                                    //         ci.options.plugins.annotation.annotations['meanLine'].display = true;
                                    //     }
                                    // }
                                    ci.update();
                            },
                            labels: {
                                generateLabels: (chart) => {
                                    const datasetLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);

                                    // Customize legend color based on dataset properties
                                    datasetLabels.forEach(label => {
                                        const dataset = chart.data.datasets[label.datasetIndex];
                                        if (dataset.label === 'All' && dataset.legendColor) {
                                            label.fillStyle = dataset.legendColor;
                                            label.strokeStyle = dataset.legendColor;
                                        }
                                        
                                    });
                                    return datasetLabels;
                                    
                                }
                            },
                            

                        },
                        /*end of legend*/
                        
                    }
                }
            });
            
            
            // Helper function to create histogram data
            function getHistogramData(data, binSize = 30) {
                const bins = Array.from({ length: Math.ceil(600 / binSize) }, (_, i) => ({
                    binStart: i * binSize,
                    count: 0
                }));

                data.forEach(time => {
                    const binIndex = Math.min(Math.floor(time / binSize), bins.length - 1);
                    bins[binIndex].count++;
                });

                return bins;
            }

            const binSize = 30; // 30 seconds
            const allData = getHistogramData(allTimes, binSize);
            const correctData = getHistogramData(correctTimes, binSize);
            const incorrectData = getHistogramData(incorrectTimes, binSize);
            const notAttemptedData = getHistogramData(notAttemptedTimes, binSize);

            hist_labels = allData.map(bin => `${(bin.binStart / 60).toFixed(1)}-${((bin.binStart + binSize) / 60).toFixed(1)} mins`);

            // Prepare data for the histogram chart
            const datasets = [
                {
                    label: 'All Questions',
                    data: allData.map(bin => bin.count),
                    backgroundColor: 'rgba(0, 0, 255, 0.5)'
                },
                {
                    label: 'Correct Questions',
                    data: correctData.map(bin => bin.count),
                    backgroundColor: 'rgba(0, 255, 0, 0.5)'
                },
                {
                    label: 'Incorrect Questions',
                    data: incorrectData.map(bin => bin.count),
                    backgroundColor: 'rgba(255, 0, 0, 0.5)'
                },
                {
                    label: 'Not attempted Questions',
                    data: notAttemptedData.map(bin => bin.count),
                    backgroundColor: 'rgba(138, 0, 241, 0.8)'
                },
            ];
            if (histogramChart) { histogramChart.destroy();}
            const ctxHistogram = document.getElementById('histogramChart').getContext('2d');
            
            histogramChart = new Chart(ctxHistogram, {
                type: 'bar',
                data: {
                    labels: hist_labels,
                    datasets: datasets,
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time (minutes)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    }
                }
            });


            const bins = 500; // Number of bins
            const maxTime = Math.max(...allTimes, ...correctTimes, ...incorrectTimes, ...notAttemptedTimes);
            const binWidth = maxTime / bins;
           
            function getCumulativeData(times, bins = 500) {
                const binWidth = maxTime / bins;
                const cumulativeData = Array(bins).fill(0);
                const sortedTimes = times.slice().sort((a, b) => a - b); // Sort times in ascending order

                let cumulativeSum = 0;
                let currentIndex = 0;

                for (let i = 0; i < bins; i++) {
                    const binEnd = binWidth * (i + 1);

                    while (currentIndex < sortedTimes.length && sortedTimes[currentIndex] <= binEnd) {
                        cumulativeSum++;
                        currentIndex++;
                    }

                    cumulativeData[i] = {
                        x: binEnd,
                        y: (cumulativeSum / times.length) * 100 // Convert to percentage
                    };
                }

                return cumulativeData;
            }

            const allCumulative = getCumulativeData(allTimes);
            const correctCumulative = getCumulativeData(correctTimes);
            const incorrectCumulative = getCumulativeData(incorrectTimes);
            const notAttemptedCumulative = getCumulativeData(notAttemptedTimes);

            const percentiles = [90, 95, 99];

            function getPercentileLines(data) {
                const colors = ['red', 'orange', 'blue'];
                
                return percentiles.map((percentile, index) => {
                    const point = data.find(point => point.y >= percentile);
                    if (point) {
                        const xValue = point.x;
                        return {
                            // id: `${percentile}`,
                            type: 'line',
                            xMin: xValue,
                            xMax: xValue,
                            borderColor: colors[index],
                            borderWidth: 2,
                            display: true,
                            label: {
                                content: `${percentile}%`,
                                enabled: true,
                                position: 'end',
                                display: true,
                            }
                        };
                    } else {
                        return null;
                    }
                }).filter(line => line !== null);
            }
            function getPercentileLines_updated(data, color,name) {
                return percentiles.map((percentile, index) => {
                    const point = data.find(point => point.y >= percentile);
                    if (point) {
                        const xValue = point.x;
                        return {
                            id: `${name}_${percentile}`,
                            type: 'line',
                            xMin: xValue,
                            xMax: xValue,
                            borderColor: color, // color = colors[index];
                            borderWidth: 2,
                            display: true,
                            label: {
                                content: `${name.slice(0,3)}:${percentile}%`,
                                enabled: true,
                                position: 'end',
                                display: true,
                            }
                        };
                    } else {
                        return null;
                    }
                }).filter(line => line !== null);
            }



            const ctxAll = document.getElementById('allChart').getContext('2d');
            if(allChart){allChart.destroy();}

            const datasetsForCum = [
                {
                    label: 'All Questions',
                    data: allCumulative,
                    borderColor: 'blue',
                    fill: false,
                    tension: .4,
                    annotations: getPercentileLines_updated(allCumulative, 'blue','all'),
                },
                {
                    label: 'Correct Questions',
                    data: correctCumulative,
                    borderColor: 'green',
                    fill: false,
                    annotations: getPercentileLines_updated(correctCumulative, 'green','correct'),
                },
                {
                    label: 'Incorrect Questions',
                    data: incorrectCumulative,
                    borderColor: 'red',
                    fill: false,
                    annotations: getPercentileLines_updated(incorrectCumulative, 'red','incorrect'),
                },
                {
                    label: 'Not Attempted Questions',
                    data: notAttemptedCumulative,
                    borderColor: 'gray',
                    fill: false,
                    annotations: getPercentileLines_updated(notAttemptedCumulative, 'gray','unattempted'),
                }
            ];

           
            allChart = new Chart(ctxAll, {
                type: 'line',
                data: {
                    datasets: datasetsForCum
                },
                options: {
                    elements: {
                        line: {
                            cubicInterpolationMode: 'monotone'
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            min: 0,
                            max: maxTime
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: datasetsForCum.flatMap(dataset => dataset.annotations)
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            // onHover: ()=> {
                            //     console.log("hovering");
                            // },
                            onClick: (e, legendItem, legend) =>{
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                const names = ['all','correct', 'incorrect', 'unattempted'];
                                const annot = ci.options.plugins.annotation.annotations;
                                if(ci.isDatasetVisible(index)){
                                    legendItem.hidden = true;
                                    ci.hide(index);

                                    annot[3*index].display = false;
                                    annot[3*index+1].display = false;
                                    annot[3*index+2].display = false;

                                    /*for(const percent of percentiles){
                                        // const item = annot.find(item => item.id===`${names[index]}_${percent}`);
                                        // if(item) item.display = false;
                                        console.log(annot[3*index]);
                                        console.log(annot[3*index].id);
                                        console.log(annot[3*index].display);

                                        // console.log(ci.options.plugins.annotation.annotations);
                                    }*/
                                }
                                else{
                                    legendItem.hidden = false;
                                    ci.show(index);
                                    annot[3*index].display = true;
                                    annot[3*index+1].display = true;
                                    annot[3*index+2].display = true;
                                    /*for(const percent of percentiles){
                                        // const item = annot.find(item => item.id===`${names[index]}_${percent}`);
                                        // if(item) item.display = true;
                                        // console.log(ci.options.plugins.annotation.annotations[0]);
                                        
                                        // console.log(annot.find(item => item.id===`${names[index]}_${percent}`));

                                    }*/
                                }
                                ci.update();
                            }
                        }
                    }
                }
            });

            /*
            allChart = new Chart(ctxAll, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'All Questions',
                            data: allCumulative,
                            borderColor: 'blue',
                            fill: false,
                            tension: .4,
                        },
                        // {
                        //     label: 'Correct Questions',
                        //     data: correctCumulative,
                        //     borderColor: 'green',
                        //     fill: false,
                        // }
                    ]
                },
                options: {
                    elements: { 
                        line: { 
                            cubicInterpolationMode: 'monotone' // You can use 'default' or 'monotone' 
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            min: 0,
                            max: maxTime
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: getPercentileLines(allCumulative)
                        }
                    }
                }
            });
            */
            if(correctChart){correctChart.destroy();}
            const ctxCorrect = document.getElementById('correctChart').getContext('2d');
            correctChart =  new Chart(ctxCorrect, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Correct Questions',
                        data: correctCumulative,
                        borderColor: 'green',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            min: 0,
                            max: maxTime
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: getPercentileLines(correctCumulative)
                        }
                    }
                }
            });
            if(incorrectChart){incorrectChart.destroy();}
            const ctxIncorrect = document.getElementById('incorrectChart').getContext('2d');
            incorrectChart = new Chart(ctxIncorrect, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Incorrect Questions',
                        data: incorrectCumulative,
                        borderColor: 'red',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            min: 0,
                            max: maxTime
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: getPercentileLines(incorrectCumulative)
                        }
                    }
                }
            });
            if(notAttemptedChart){notAttemptedChart.destroy();}
            const ctxNotAttempted = document.getElementById('notAttemptedChart').getContext('2d');
            notAttemptedChart = new Chart(ctxNotAttempted, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Not Attempted Questions',
                        data: notAttemptedCumulative,
                        borderColor: 'gray',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Time (seconds)'
                            },
                            min: 0,
                            max: maxTime
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Percentage'
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        annotation: {
                            annotations: getPercentileLines(notAttemptedCumulative)
                        }
                    }
                }
            });
            
        }
        function getStoredData() {
            const key = 'statisticsData';
            const storedData = JSON.parse(localStorage.getItem(key)) || {};
            return storedData;
        }
        
        // import { parseISO, format } from 'date-fns';
        function plotPerformanceGraph() {
            const statType = document.getElementById('statType').value;
            const subjectType = document.getElementById('subjectSelect').value;
            const responseType = document.getElementById('responseType').value;
            const data = getStoredData();

            if (!data[subjectType]) {
                alert(`No data available for subject: ${subjectType}`);
                return;
            }

            const statKey = `${responseType}_${statType}`;
            if (!data[subjectType][statKey]) {
                alert(`No data available for ${responseType} with statistical measure: ${statType}`);
                return;
            }

            const statData = data[subjectType][statKey];
            const labels = Object.keys(statData).map(date => new Date(date));
            console.log(labels);
            // const labels = Object.keys(statData);
            const values = Object.values(statData);

            if(performanceChart){
                performanceChart.destroy();
            }
            const ctxperformanceChart = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(ctxperformanceChart, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${statType} over time for ${subjectType} (${responseType})`,
                        data: values,
                        borderColor: 'blue',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                minUnit: 'day',
                                tooltipFormat: 'dd MMM yyyy HH:mm',
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            },
                            ticks: { 
                                autoSkip: true,
                                maxTicksLimit: 10,
                                // callback: function(value, index, values) { 
                                //     return dateFns.format(value, 'dd MMM yyyy HH:mm');
                                // } 
                            },
                        },
                        y: {
                            title: {
                                display: true,
                                text: statType
                            }
                        }
                    }
                }, 
                plugins: { 
                    legend: { 
                        display: true 
                    }, 
                    tooltip: { 
                        mode: 'index', 
                        intersect: false 
                    } 
                }
            });

        }

    </script>
</body>
</html>